//License: https://github.com/TWal/rubik.js/blob/master/LICENSE

Rubikjs.Render.Canvas.Renderer=function(b){Rubikjs.Render.Renderer.call(this,b);if(void 0!=("canvas"==b.localName?b:void 0))try{this.ctx=b.getContext("2d"),void 0==this.ctx&&alert("No canvas :(")}catch(a){}this.triangles=[]};Rubikjs.Render.Canvas.Renderer.prototype=new Rubikjs.Render.Renderer;Rubikjs.Render.Canvas.Renderer.prototype.constructor=Rubikjs.Render.Canvas.Renderer;Rubikjs.Render.Canvas.Renderer.prototype.startFrame=function(){this.triangles=[]};
Rubikjs.Render.Canvas.Renderer.prototype.render=function(b){var a=mat4.create();mat4.multiply(a,this.perspectiveMat,b.transform);for(var e=0.5*this.element.offsetWidth,f=0.5*this.element.offsetHeight,g=[],d=0;d<b.vertexBuffer.data.length;d+=3){var c=vec4.create();vec4.transformMat4(c,[b.vertexBuffer.data[d],b.vertexBuffer.data[d+1],b.vertexBuffer.data[d+2],1],a);c[0]=-c[0];var h=1/c[3];c[0]*=h;c[1]*=h;c[2]*=h;c[3]=1;c[0]=(1-c[0])*e+0.5|0;c[1]=(1-c[1])*f+0.5|0;g.push(c)}for(d=0;d<b.indexBuffer.data.length;d+=
3)a=4*b.indexBuffer.data[d],a={pt0:g[b.indexBuffer.data[d]],pt1:g[b.indexBuffer.data[d+1]],pt2:g[b.indexBuffer.data[d+2]],color:[255*b.colorBuffer.data[a]+0.5|0,255*b.colorBuffer.data[a+1]+0.5|0,255*b.colorBuffer.data[a+2]+0.5|0,255*b.colorBuffer.data[a+3]+0.5|0],zmean:0},a.zmean=(a.pt0[2]+a.pt1[2]+a.pt2[2])/3,this.triangles.push(a)};
Rubikjs.Render.Canvas.Renderer.prototype.endFrame=function(){this.triangles.sort(function(a,b){return b.zmean-a.zmean});this.ctx.clearRect(0,0,this.element.offsetWidth,this.element.offsetHeight);var b="",a=this;this.triangles.forEach(function(e){var f="rgba("+e.color[0]+", "+e.color[1]+", "+e.color[2]+", "+e.color[3]+")";f!=b&&(a.ctx.fillStyle=f,b=a.ctx.strokeStyle=f);a.ctx.beginPath();a.ctx.moveTo(e.pt0[0],e.pt0[1]);a.ctx.lineTo(e.pt1[0],e.pt1[1]);a.ctx.lineTo(e.pt2[0],e.pt2[1]);a.ctx.closePath();
a.ctx.fill();a.ctx.stroke()})};Rubikjs.Render.Canvas.Renderer.prototype.createMesh=function(){return new Rubikjs.Render.Mesh};
